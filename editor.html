<!DOCTYPE html>
<html data-bs-theme="auto">

<head>
    <meta http-equiv="Content-Language" content="en_US" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="SanjiraTree" />
    <meta name="author" content="Eldiiar Bekbolotov" />
    <meta name="keywords" content="SanjiraByEldiiar,FamilyTree,Application,EldiiarBekbolotov" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Roboto+Serif:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.0.0/css/flag-icons.min.css" />
    <title>Editor | SanjiraTree</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="font/bootstrap-icons.woff">
    <link rel="stylesheet" href="font/bootstrap-icons.woff2">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/removegt.css">
    <!-- Doesn't work without CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta charset="UTF-8" />
    <script type='application/javascript'>
        const preloadedData = { "nodes": [{ "x": 144, "y": 179, "name": "Kumar", "info": "Info \nqwe", "imageSrc": "" }, { "x": 384, "y": 179, "name": "Mirgul", "info": "Infoqwe", "imageSrc": "" }, { "x": 158.01647927216584, "y": 437.70062655566124, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 747.8331158885951, "y": 417.03159566623253, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 82.78688524590179, "y": 662.2950819672143, "name": "Name", "info": "Info", "imageSrc": null }, { "x": -26.229508196721362, "y": 426.2295081967221, "name": "Name", "info": "Info", "imageSrc": null }, { "x": -100.81967213114773, "y": 699.1803278688537, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 262.7573883941237, "y": 672.5112031312052, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 963.6678200692087, "y": 408.30449826989803, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 949.8269896193814, "y": 621.107266435989, "name": "Name", "info": "Info", "imageSrc": null }, { "x": 5512, "y": 528, "name": "Name", "info": "Info", "imageSrc": null }], "connections": [{ "node1": 1, "node2": 0 }, { "node1": 2, "node2": 0 }, { "node1": 3, "node2": 1 }, { "node1": 2, "node2": 1 }, { "node1": 3, "node2": 0 }, { "node1": 2, "node2": 4 }, { "node1": 5, "node2": 2 }, { "node1": 5, "node2": 4 }, { "node1": 6, "node2": 2 }, { "node1": 6, "node2": 5 }, { "node1": 7, "node2": 2 }, { "node1": 7, "node2": 5 }, { "node1": 3, "node2": 8 }, { "node1": 3, "node2": 9 }, { "node1": 8, "node2": 9 }] };
    </script>
    <style>
        canvas {
            border: 2px solid rgb(103, 103, 103);
            cursor: default;
            width: 100vw;
            height: 80vh;
        }

        .info-box {
            position: fixed;
            left: 0;
            bottom: 0;
            height: 33vh;
            width: 100vw;
            display: none;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            overflow: auto;
            z-index: 999;
        }

        .info-box input,
        .info-box textarea {
            width: calc(100% - 125px);
        }

        #info-box-close-button {
            position: fixed;
            right: 10px;
            bottom: 27vh;
            bottom: calc(33vh - 50px);
            padding: 0 9px !important;
        }

        #info-box-save-button {
            position: fixed;
            right: 10px;
            bottom: 10px;
            padding: 0 9px !important;
        }

        #info-box-delete-button {
            position: fixed;
            padding: 0 9px !important;
            right: 10px;
            bottom: 15vh;
            bottom: calc(16.5vh - 20px);
        }

        .new-node-button {
            margin: 0px;
        }
    </style>
</head>

<body>
    <noscript>
        Sorry, your browser does not support JavaScript, which is needed to run this application!
    </noscript>




    <div>

        <canvas id="familyTreeCanvas" width='600' height='600'></canvas>
        <div class="d-flex align-content-end flex-wrap">
            <button role="button" class="new-node-button btn btn-success mx-2 my-1" onclick="startNewNode()"><i
                    class="bi-person-add" aria-hidden="true"></i> New Member</button>
            <button type="button" class="btn btn-primary mx-2 my-1" data-bs-toggle="modal"
                data-bs-target="#exampleModal" onclick="saveData()">
                <i class="bi-save" aria-hidden="true"></i> Get Save Code
            </button>

            <button role='button' class="btn btn-outline-secondary mx-2 my-1" onclick="loadData()"><i class="bi-upload"
                    aria-hidden="true"></i> Load Save Code</button>
            <button role='button' class="btn btn-danger text-light mx-2 my-1" onclick="saveLocalData()"><i
                    class="bi-save" aria-hidden="true"></i> Local Save</button>

            <button role='button' class="btn btn-outline-secondary mx-2 my-1" onclick="loadSavedData()"><i
                    class="bi-upload" aria-hidden="true"></i> Load Local Save</button>
        </div>
        <div id="infoBox" class="info-box card">

            <button id="info-box-close-button" type="button" class="btn btn-secondary" onclick="closeInfoBox();"><i
                    class="bi-x-circle" aria-hidden="true"></i> Close</button>

            <div class="mb-3"> <label>Name: </label><input type="text" id="nameInput" class="form-control"
                    placeholder="Name"></div>
            <div class="mb-3"> <label>Info: </label><textarea id="infoInput" rows="3" class="form-control"></textarea>
            </div>
            <div class="mb-3"> <label>Image URL: </label><input type="text" id="imageInput" class="form-control"></div>
            <button type="button" id='info-box-save-button' class="btn btn-success" onclick="saveNode()"><i
                    class="bi-save-fill" aria-hidden="true"></i> Save</button>
            <button type="button" id="info-box-delete-button" class="btn btn-danger" onclick="deleteNode()"><i
                    class="bi-trash" aria-hidden="true"></i> Delete</button>

        </div>

    </div>

    <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Modal title</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"
                        onclick="closeModal();"></button>
                </div>
                <div class="modal-body">
                    ...
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="copyModal();"><i
                            class="bi-copy" aria-hidden="true"></i> Copy</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal"
                        onclick="closeModal();">Close</button>

                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="liveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">

            <div class="toast-body">
                <i class="bi-clipboard-check" aria-info-hidden="true"></i> Save Code Copied to Clipboard
            </div>
        </div>
    </div>

    <footer class="d-flex flex-wrap justify-content-between align-items-center py-3 px-3 border-top">
        <div class="col-md-4 d-flex align-items-center">
            <span class="mb-md-0 text-body-secondary">&copy; 2024 Eldiiar Bekbolotov</span>
        </div>
        <ul class="nav col-md-4 justify-content-end list-unstyled d-flex">
            <li class="ms-3"><button id="theme-toggle" class="btn btn-primary notranslate"><i class="bi-moon-stars-fill"
                        aria-info-hidden="true"></i> Dark</button>
            </li>
            <li class="ms-3"><a class="text-body-secondary" href="https://github.com/Longfields" target="_blank"><i
                        class="bi bi-github" style="position:relative;top:6px;"></i></a></li>
        </ul>
    </footer>
    <nav class="navbar navbar-expand-lg bg-dark navbar-dark">
        <div class="d-flex flex-wrap justify-content-between align-items-center container-fluid">
            <a class="nav-link text-light" href="index.html"><i class="bi-arrow-left" aria-hidden="true"></i>Home
                Page</a>
            <a class="navbar-brand" href="index.html"><i class="bi-person-arms-up" aria-hidden="true"></i>
                SanjiraTree</a>

        </div>


    </nav>
    <div id="google_translate_element"></div>

    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js'></script>
    <script src="js/initializegt.js"> </script>
    <script type="text/javascript"
        src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
    <script type='text/javascript' src="js/index.js"></script>
    <!--<script type='text/javascript' src="js/Sanjiratree.js"></script>-->

    <script src="js/bootstrap.bundle.min.js"></script>
    <script type="application/javascript">
        const myModal = new bootstrap.Modal(document.getElementById('exampleModal'));
        function closeModal() {
            myModal.hide();
        }

        const themeToggle = document.getElementById('theme-toggle');
        themeToggle.addEventListener('click', () => {
            const htmlElement = document.documentElement;
            const currentTheme = htmlElement.getAttribute('data-bs-theme');

            if (currentTheme === 'light') {
                htmlElement.setAttribute('data-bs-theme', 'dark');
                document.getElementById('theme-toggle').innerHTML = `<i class="bi-sun-fill notranslate" aria-info-hidden="true"></i> Light`;

            } else if (currentTheme === 'dark') {
                htmlElement.setAttribute('data-bs-theme', 'light');
                document.getElementById('theme-toggle').innerHTML = `<i class="bi-moon-stars-fill notranslate" aria-info-hidden="true"></i> Dark`;

            } else {
                htmlElement.setAttribute('data-bs-theme', 'dark');
                document.getElementById('theme-toggle').innerHTML = `<i class="bi-sun-fill notranslate" aria-info-hidden="true"></i> Light`;

            }
        });
    </script>
    <script type="application/javascript">
        const canvas = document.getElementById('familyTreeCanvas');
        const ctx = canvas.getContext('2d');
        const infoBox = document.getElementById('infoBox');
        const nameInput = document.getElementById('nameInput');
        const infoInput = document.getElementById('infoInput');
        const imageInput = document.getElementById('imageInput');
        canvas.width = canvas.getBoundingClientRect().width * devicePixelRatio;
        canvas.height = canvas.getBoundingClientRect().height * devicePixelRatio;
        ctx.scale(devicePixelRatio, devicePixelRatio);

        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let isDraggingNode = false;
        let isDraggingCanvas = false;
        let dragOffsetX = 0,
            dragOffsetY = 0;
        let scale = 1;
        let offsetX = 0,
            offsetY = 0;
        let newNodeMode = false;
        let startConnectNode = null; // Store the start node for connections
        const CIRCLE_RADIUS = 15;

        class Node {
            constructor(x, y, name = "Name", info = "Info", imageSrc = null) {
                this.x = x;
                this.y = y;
                this.width = 120;
                this.height = 120;
                this.name = name;
                this.info = info;
                this.imageSrc = imageSrc;
                this.image = new Image();
                if (imageSrc) {
                    this.image.src = imageSrc;
                }
            }

            draw() {
                ctx.fillStyle = "#344e41";

                ctx.lineWidth = 0;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                if (this.image.src) {
                    ctx.drawImage(this.image, this.x + 5, this.y + 25, this.width / 1.3, this.height / 1.3);
                }
                ctx.drawImage(this.image, this.x + 5, this.y + 25, this.width / 1.3, this.height / 1.3);

                ctx.fillStyle = "white";
                ctx.font = 12 + "px Arial";
                ctx.fillText(this.name, this.x + 5, this.y + 15);


                this.drawConnectionPoints();
            }

            drawConnectionPoints() {
                const point = { x: this.x + this.width / 2, y: this.y + this.height };
                ctx.fillStyle = '#588157';
                ctx.beginPath();
                ctx.arc(point.x, point.y, CIRCLE_RADIUS, Math.PI, 0);
                ctx.fill();
            }

            isClicked(mouseX, mouseY) {
                return mouseX >= this.x && mouseX <= this.x + this.width &&
                    mouseY >= this.y && mouseY <= this.y + this.height;
            }

            isBottomConnectionClicked(mouseX, mouseY) {
                const bottomPoint = { x: this.x + this.width / 2, y: this.y + this.height };
                return Math.sqrt((mouseX - bottomPoint.x) ** 2 + (mouseY - bottomPoint.y) ** 2) < CIRCLE_RADIUS;
            }

            showInfo() {
                infoBox.style.display = 'block';
                nameInput.value = this.name;
                infoInput.value = this.info;
                imageInput.value = this.imageSrc || '';
                selectedNode = this;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            for (const connection of connections) {
                ctx.beginPath();
                ctx.moveTo(connection.node1.x + connection.node1.width / 2, connection.node1.y + connection.node1.height / 2);
                ctx.lineTo(connection.node2.x + connection.node2.width / 2, connection.node2.y + connection.node2.height / 2);
                ctx.strokeStyle = 'black';
                ctx.stroke();
            }

            for (const node of nodes) {
                node.draw();
            }

            ctx.restore();
        }

        canvas.addEventListener('mousedown', startInteraction);
        canvas.addEventListener('mousemove', moveInteraction);
        canvas.addEventListener('mouseup', endInteraction);
        canvas.addEventListener('mouseleave', endInteraction); // For when the pointer leaves the canvas
        canvas.addEventListener('touchstart', startInteraction, { passive: false });
        canvas.addEventListener('touchmove', moveInteraction, { passive: false });
        canvas.addEventListener('touchend', endInteraction);

        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomAmount = -event.deltaY * 0.001;
            adjustZoom(event.offsetX, event.offsetY, zoomAmount);
        });

        // For pinch zoom
        let lastTouchDistance = null;

        function startInteraction(event) {
            event.preventDefault();

            // Handle pinch zoom for touch devices
            if (event.touches) {
                if (event.touches.length === 2) {
                    lastTouchDistance = getTouchDistance(event.touches);
                    return;
                }
                const touch = event.touches[0];
                dragOffsetX = touch.clientX;
                dragOffsetY = touch.clientY;
            } else {
                dragOffsetX = event.offsetX;
                dragOffsetY = event.offsetY;
            }

            const { x, y } = getCanvasCoordinates(event);

            // Create a new node if in newNodeMode
            if (newNodeMode) {
                const newNode = new Node(x, y); // Default properties can be modified as needed
                nodes.push(newNode);
                newNodeMode = false; // Disable new node creation mode after the node is created
                selectedNode = newNode; // Select the new node for further edits if needed
                draw(); // Redraw the canvas to show the new node
                return;
            }

            // Handle connecting nodes
            if (!startConnectNode) {
                startConnectNode = nodes.find(node => node.isBottomConnectionClicked(x, y));
                if (startConnectNode) return; // Wait for the second node click
            } else {
                const endConnectNode = nodes.find(node => node.isClicked(x, y));
                if (endConnectNode && endConnectNode !== startConnectNode) {
                    connections.push({ node1: startConnectNode, node2: endConnectNode });
                }
                startConnectNode = null; // Reset connection start node
                draw(); // Redraw to show the connection
                return;
            }

            // Handle existing node selection or canvas dragging
            selectedNode = nodes.find(node => node.isClicked(x, y));

            if (selectedNode) {
                isDraggingNode = true;
                dragOffsetX = x - selectedNode.x;
                dragOffsetY = y - selectedNode.y;
                selectedNode.showInfo();
            } else {
                isDraggingCanvas = true;
            }
        }



        function moveInteraction(event) {
            event.preventDefault();
            if (event.touches && event.touches.length === 2) {
                const newTouchDistance = getTouchDistance(event.touches);
                const zoomAmount = (newTouchDistance - lastTouchDistance) * 0.001;
                lastTouchDistance = newTouchDistance;

                const touchCenter = getTouchCenter(event.touches);
                adjustZoom(touchCenter.x, touchCenter.y, zoomAmount);
                return;
            }

            if (isDraggingCanvas) {
                const { dx, dy } = getDragDelta(event);
                offsetX += dx;
                offsetY += dy;
                draw();
            } else if (isDraggingNode && selectedNode) {
                const { x, y } = getCanvasCoordinates(event);
                selectedNode.x = x - dragOffsetX;
                selectedNode.y = y - dragOffsetY;
                draw();
            }
        }

        function endInteraction(event) {
            isDraggingNode = false;
            isDraggingCanvas = false;
            lastTouchDistance = null;
        }

        function adjustZoom(centerX, centerY, zoomAmount) {
            const newScale = Math.min(Math.max(0.125, scale + zoomAmount), 4);
            const scaleFactor = newScale / scale;
            offsetX -= (centerX - offsetX) * (scaleFactor - 1);
            offsetY -= (centerY - offsetY) * (scaleFactor - 1);
            scale = newScale;
            draw();
        }

        function getCanvasCoordinates(event) {
            if (event.touches) {
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (touch.clientX - rect.left - offsetX) / scale,
                    y: (touch.clientY - rect.top - offsetY) / scale,
                };
            }
            return {
                x: (event.offsetX - offsetX) / scale,
                y: (event.offsetY - offsetY) / scale,
            };
        }

        function getDragDelta(event) {
            if (event.touches) {
                const touch = event.touches[0];
                const dx = touch.clientX - dragOffsetX;
                const dy = touch.clientY - dragOffsetY;
                dragOffsetX = touch.clientX;
                dragOffsetY = touch.clientY;
                return { dx, dy };
            }
            const dx = event.offsetX - dragOffsetX;
            const dy = event.offsetY - dragOffsetY;
            dragOffsetX = event.offsetX;
            dragOffsetY = event.offsetY;
            return { dx, dy };
        }

        function getTouchDistance(touches) {
            const [touch1, touch2] = touches;
            return Math.sqrt(
                (touch1.clientX - touch2.clientX) ** 2 +
                (touch1.clientY - touch2.clientY) ** 2
            );
        }

        function getTouchCenter(touches) {
            const [touch1, touch2] = touches;
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2,
            };
        }

        function startNewNode() {
            newNodeMode = true;
            infoBox.style.display = 'none';
        }

        function saveNode() {
            if (selectedNode) {
                selectedNode.name = nameInput.value;
                selectedNode.info = infoInput.value;
                selectedNode.imageSrc = imageInput.value;
                selectedNode.image = new Image();
                if (selectedNode.imageSrc) {
                    selectedNode.image.src = selectedNode.imageSrc;
                }
                draw();
            }
        }

        function deleteNode() {
            if (selectedNode) {
                nodes = nodes.filter(node => node !== selectedNode);
                connections = connections.filter(connection => connection.node1 !== selectedNode && connection.node2 !== selectedNode);
                selectedNode = null;
                infoBox.style.display = 'none';
                draw();
            }
        }

        function closeInfoBox() {
            infoBox.style.display = 'none';
        }

        function saveData() {
            const data = {
                nodes: nodes.map(node => ({
                    x: node.x,
                    y: node.y,
                    name: node.name,
                    info: node.info,
                    imageSrc: node.imageSrc
                })),
                connections: connections.map(connection => ({
                    node1: nodes.indexOf(connection.node1),
                    node2: nodes.indexOf(connection.node2)
                }))
            };
            document.querySelector('#exampleModal .modal-body').innerHTML = `<p class='noselect'>Copy + Save this:</p><code style='margin-top:30px;'>${JSON.stringify(data)}</code>`;

        }

        function copyModal() {
            var data = {
                nodes: nodes.map(node => ({
                    x: node.x,
                    y: node.y,
                    name: node.name,
                    info: node.info,
                    imageSrc: node.imageSrc
                })),
                connections: connections.map(connection => ({
                    node1: nodes.indexOf(connection.node1),
                    node2: nodes.indexOf(connection.node2)
                }))
            };

            var jsonString = JSON.stringify(data);

            navigator.clipboard.writeText(jsonString)
                .then(() => {

                })
                .catch(err => {
                    var copyText = document.createElement("input");
                    var z = JSON.stringify(data);
                    copyText.value = z;
                    copyText.select();
                    copyText.setSelectionRange(0, 99999);
                    navigator.clipboard.writeText(copyText.value);
                });
            const toastLiveExample = document.getElementById('liveToast');

            const toastBootstrap = bootstrap.Toast.getOrCreateInstance(toastLiveExample);
            toastBootstrap.show();
            setTimeout(function () {
                toastBootstrap.hide();
            }, 4000)
        }

        function saveLocalData() {
            const data = {
                nodes: nodes.map(node => ({
                    x: node.x,
                    y: node.y,
                    name: node.name,
                    info: node.info,
                    imageSrc: node.imageSrc
                })),
                connections: connections.map(connection => ({
                    node1: nodes.indexOf(connection.node1),
                    node2: nodes.indexOf(connection.node2)
                }))
            };
            localStorage.setItem('familyTreeData', JSON.stringify(data));
            alert('Data saved!');
        }

        function loadData() {
            const manualPrompt = prompt('Enter');
            const manualData = JSON.parse(manualPrompt);
            if (manualPrompt) {
                nodes = manualData.nodes.map(nodeData => new Node(nodeData.x, nodeData.y, nodeData.name, nodeData.info, nodeData.imageSrc));
                connections = manualData.connections.map(connection => ({
                    node1: nodes[connection.node1],
                    node2: nodes[connection.node2]
                }));
            }
            draw();
        }

        function loadSavedData() {
            const data = JSON.parse(localStorage.getItem('familyTreeData'));
            if (data) {
                nodes = data.nodes.map(nodeData => new Node(nodeData.x, nodeData.y, nodeData.name, nodeData.info, nodeData.imageSrc));
                connections = data.connections.map(connection => ({
                    node1: nodes[connection.node1],
                    node2: nodes[connection.node2]
                }));
                draw();
                alert('Data loaded!');
            } else {
                alert('No saved data found.');
            }
        }

        draw();

        function preloadData() {
            nodes = preloadedData.nodes.map(nodeData => new Node(nodeData.x, nodeData.y, nodeData.name, nodeData.info, nodeData.imageSrc));
            connections = preloadedData.connections.map(connection => ({
                node1: nodes[connection.node1],
                node2: nodes[connection.node2]
            }));
            draw();
        }
        //preloadData();
    </script>

</body>

</html>